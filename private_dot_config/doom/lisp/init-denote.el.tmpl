;;; +denote.el -*- mode: emacs-lisp; lexical-binding: t; -*-

;;; Commentary:
;; - Projects: Active projects with deadlines
;; - Areas: Ongoing responsibilities
;; - Resources: Topics of ongoing interest
;; - Archive: Inactive items

(use-package! denote
  :config
  ;; Dedicated denote directory
  (setq denote-directory {{ .org_dir | quote }})

  ;; Exclude certain directories from being scanned for notes (e.g., data, attachments)
  (setq denote-excluded-directories-regexp ".attach\\|data\\|images")

  ;; Lifecycle keywords (inspired by EWS)
  (setq denote-known-keywords
        '("project" "area" "resource" "archive"
          "reference" "meeting" "finance" "work" "personal"
          "idea" "draft" "completed" "journal"
          "health" "shopping" "selling" "hold" "someday" "visit" "administration" "research"))

  ;; Sort keywords for consistency
  (setq denote-sort-keywords t)

  ;; Enable buffer renaming to show clean [D] prefix instead of long filename
  (denote-rename-buffer-mode 1)

  ;; Make Denote notes open in full screen
  (add-to-list 'display-buffer-alist
               '("^\\[D\\]" ; Match buffers starting with [D]
                 (display-buffer-reuse-mode-window display-buffer-same-window)))

  ;; Dired integration
  (add-hook 'dired-mode-hook #'denote-dired-mode)

  ;; File type defaults
  (setq denote-file-type 'org)

  ;; Create denote directory if it doesn't exist
  (unless (file-exists-p denote-directory)
    (make-directory denote-directory t))

  ;; Extra workspace directory helper
  (defun my/denote-extra-dir ()
    "Return extra denote directory if it exists, nil otherwise."
    (let ((dir (expand-file-name "org" {{ .workspace_extra | quote }})))
      (when (file-exists-p dir) dir)))

  ;; Collect denote files from all directories
  (defun my/denote-all-files ()
    "Return denote files from both primary and extra directories."
    (let ((primary-files (denote-directory-files))
          (extra-dir (my/denote-extra-dir)))
      (if extra-dir
          (let ((denote-directory extra-dir))
            (append primary-files (denote-directory-files)))
        primary-files)))

  ;; Make all denote commands that use denote-file-prompt search both dirs
  (advice-add 'denote-file-prompt :around
              (lambda (orig-fn &rest args)
                "Override denote-file-prompt to search all directories."
                (let ((all-files (my/denote-all-files)))
                  (completing-read (or (cadr args) "Select note: ")
                                   all-files nil t nil 'denote-file-history))))

  ;; Make link following (C-c C-o) find files from extra dir
  (advice-add 'denote-get-path-by-id :around
              (lambda (orig-fn id &rest args)
                "Search extra dir if file not found in primary."
                (or (apply orig-fn id args)
                    (let ((extra-dir (my/denote-extra-dir)))
                      (when extra-dir
                        (let ((denote-directory extra-dir))
                          (apply orig-fn id args)))))))

  ;; Create denote note in extra workspace
  (defun my/denote-create-in-extra ()
    "Create denote note in extra workspace."
    (interactive)
    (let ((extra-dir (my/denote-extra-dir)))
      (if extra-dir
          (let ((denote-directory extra-dir))
            (call-interactively #'denote))
        (message "Extra workspace not mounted."))))

  ;; Dired showing both denote directories
  (defun my/denote-dired ()
    "Open dired with all denote directories."
    (interactive)
    (let ((dirs (list denote-directory))
          (extra-dir (my/denote-extra-dir)))
      (when extra-dir (push extra-dir dirs))
      (dired (cons "Denote" dirs))))

  ;; Find across all denote directories
  (defun my/denote-find ()
    "Find denote files across all directories."
    (interactive)
    (find-file (completing-read "Find note: " (my/denote-all-files) nil t)))

  ;; Custom function to check if a file has a specific keyword
  (defun denote-file-has-keyword-p (file keyword)
    "Return non-nil if FILE has KEYWORD in its denote keywords.
KEYWORD should be a string. FILE should be a full file path."
    (when-let ((keywords (denote-extract-keywords-from-path file)))
      (member keyword keywords))))

(use-package! denote-explore
  :after denote
  :config
  ;; Network visualization for note connections
  (setq denote-explore-network-filename "denote-network.html")
  (setq denote-explore-network-directory denote-directory))

(use-package! consult-notes
  :config
  ;; Dynamic function to get all available denote directories
  (defun my/get-consult-notes-sources ()
    "Get consult-notes sources for all available denote directories."
    (let ((sources `(("Denote Primary" ?d ,denote-directory))))
      (let ((extra-denote-dir (expand-file-name "org" {{ .workspace_extra | quote }})))
        (when (file-exists-p extra-denote-dir)
          (push `("Denote Extra" ?x ,extra-denote-dir) sources)))
      (reverse sources)))

  ;; Override consult-notes to always use fresh sources
  (advice-add 'consult-notes :before
              (lambda (&rest _)
                (setq consult-notes-file-dir-sources (my/get-consult-notes-sources))))

  ;; Set initial sources
  (setq consult-notes-file-dir-sources (my/get-consult-notes-sources))

  ;; Manual refresh function
  (defun my/refresh-consult-notes-sources ()
    "Refresh consult-notes sources to include mounted directories."
    (interactive)
    (setq consult-notes-file-dir-sources (my/get-consult-notes-sources))
    (message "Refreshed consult-notes sources: %d sources" (length consult-notes-file-dir-sources)))

  ;; Debug function to check what's happening
  (defun my/debug-denote-dirs ()
    "Debug denote directory configuration."
    (interactive)
    (let ((extra-dir (my/denote-extra-dir)))
      (message "Primary denote dir: %s (exists: %s)"
               denote-directory (file-exists-p denote-directory))
      (message "Extra denote dir: %s (exists: %s)"
               (or extra-dir "N/A") (if extra-dir t nil))
      (message "Consult-notes sources: %s"
               (mapcar #'car consult-notes-file-dir-sources))
      (message "Denote files found: %d"
               (length (denote-directory-files)))))

  ;; Enable live preview
  (consult-notes-org-headings-mode 1))

(use-package! denote-journal
  :after denote
  :config
  ;; Dedicated journal subdirectory
  (setq denote-journal-directory (expand-file-name "journal" denote-directory))

  ;; Journal entry keyword
  (setq denote-journal-keyword "journal")

  ;; Date selection interface (use org-read-date for better UX)
  (setq denote-date-prompt-use-org-read-date t)

  ;; Title format for journal entries - simple date format
  (setq denote-journal-title-format "%Y-%m-%d")

  ;; Auto-save journal entries
  (setq denote-journal-auto-save-buffer t)

  ;; Create journal directory if it doesn't exist
  (unless (file-exists-p denote-journal-directory)
    (make-directory denote-journal-directory t))

  ;; Automatic tempel daily-journal insertion for new journal entries
  (defun my/denote-journal-insert-tempel ()
    "Insert daily-journal tempel template for new journal entries."
    (when (and (derived-mode-p 'org-mode)
               (buffer-file-name)
               (string-match-p "journal" (buffer-file-name))
               (not buffer-read-only))
      (save-excursion
        (goto-char (point-min))
        ;; Skip past frontmatter if it exists
        (when (looking-at "#\\+")
          (while (and (not (eobp)) (looking-at "#\\+"))
            (forward-line 1))
          (when (looking-at "^$")
            (forward-line 1)))
        ;; Only insert if no content after frontmatter
        (when (eobp)
          (condition-case err
              (progn
                (require 'tempel)
                (tempel-insert 'daily-journal))
            (error
             (message "Error inserting daily-journal template: %s" (error-message-string err))))))))

  ;; Use find-file-hook to automatically insert template
  (add-hook 'find-file-hook #'my/denote-journal-insert-tempel)

  ;; Remove problematic advice and use simpler approach
  (advice-remove 'denote-journal-new-entry #'my/denote-journal-advice)
  (advice-remove 'denote-journal-new-or-existing-entry #'my/denote-journal-advice)

  ;; Enable calendar integration
  (require 'calendar)
  (add-hook 'calendar-today-visible-hook #'denote-journal-calendar-mark-dates)
  (add-hook 'calendar-today-invisible-hook #'denote-journal-calendar-mark-dates))

;; Additional denote packages
(use-package! denote-org
  :after denote)

(use-package! denote-sequence
  :after denote)

(use-package! denote-explore
  :after denote)

;; Consult-Notes for easy access to notes
(use-package! consult-notes
  :after (denote consult)
  :config
  (setq consult-notes-denote-display-keywords-indicator "_")
  ;; Don't enable consult-notes-denote-mode — it only uses denote-directory (main).
  ;; Instead, rely on consult-notes-file-dir-sources which covers both dirs.
  )

;; Citar-Denote to manage literature notes
(use-package! citar-denote
  :after (denote citar)
  :config
  (setq citar-open-always-create-notes t)
  (citar-denote-mode))

;; Custom org link for today's journal
(org-link-set-parameters "today-journal"
                         :follow #'my/open-today-journal)

(defun my/open-today-journal (path)
  "Open today's denote journal entry."
  (denote-journal-new-or-existing-entry))

;; Calendar integration for denote journal
(defun my/calendar-open-journal ()
  "Open or create journal entry for the date at point in calendar."
  (interactive)
  (let* ((date (calendar-cursor-to-date))
         (year (calendar-extract-year date))
         (month (calendar-extract-month date))
         (day (calendar-extract-day date))
         (target-date (encode-time 0 0 0 day month year))
         (date-string (format-time-string "%Y-%m-%d" target-date)))
    ;; Check if journal entry exists for this date
    (let* ((journal-dir denote-journal-directory)
           (journal-pattern (concat date-string ".*\\.org$"))
           (existing-files (when (file-exists-p journal-dir)
                            (directory-files journal-dir nil journal-pattern))))
      (if existing-files
          ;; Open existing journal entry
          (find-file (expand-file-name (car existing-files) journal-dir))
        ;; Create new journal entry for the specific date
        (let ((denote-directory denote-journal-directory)
              (title (format "Journal %s" date-string)))
          (denote title (list denote-journal-keyword) 'org date-string))))))

;; Hook calendar to open journal on RET
(add-hook 'calendar-mode-hook
          (lambda ()
            (define-key calendar-mode-map (kbd "RET") #'my/calendar-open-journal)
            (define-key calendar-mode-map (kbd "<return>") #'my/calendar-open-journal)))

;; Function to open inbox.org
(defun my/open-inbox ()
  "Open the inbox.org file."
  (interactive)
  (find-file (expand-file-name "inbox.org" {{ .org_dir | quote }})))

;; Function to open yesterday's journal
(defun my/open-yesterday-journal ()
  "Open yesterday's denote journal entry."
  (interactive)
  (let* ((yesterday (time-subtract (current-time) (days-to-time 1)))
         (date-string (format-time-string "%Y-%m-%d" yesterday)))
    (denote-journal-extras-new-or-existing-entry date-string)))

;; Function to open tomorrow's journal
(defun my/open-tomorrow-journal ()
  "Open tomorrow's denote journal entry."
  (interactive)
  (let* ((tomorrow (time-add (current-time) (days-to-time 1)))
         (date-string (format-time-string "%Y-%m-%d" tomorrow)))
    (denote-journal-extras-new-or-existing-entry date-string)))

;; Scrollable journal feed - all denote files in one buffer
(defun my/denote-feed-open-entry ()
  "Open the journal file for the entry at point for editing."
  (interactive)
  (let ((file (get-text-property (point) 'denote-feed-file)))
    (if file
        (find-file file)
      (message "No journal entry at point"))))

(defun my/denote-feed ()
  "Show all denote journal entries as a scrollable feed, newest first.
Press RET or TAB on any entry to open it for editing."
  (interactive)
  (let* ((journal-dir denote-journal-directory)
         (files (when (file-exists-p journal-dir)
                  (directory-files journal-dir t "\\.org$")))
         (sorted (sort (copy-sequence files) (lambda (a b)
                               (string> (file-name-nondirectory a)
                                        (file-name-nondirectory b)))))
         (buf (get-buffer-create "*Denote Journal Feed*")))
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)
        (org-mode)
        (insert "#+title: Journal Feed\n")
        (insert "# RET / TAB on any entry to open and edit it\n\n")
        (dolist (file sorted)
          (let* ((title (or (denote-retrieve-front-matter-title-value file 'org)
                            (file-name-base file)))
                 (id (denote-retrieve-filename-identifier file))
                 (date (when (>= (length id) 8)
                         (format "%s-%s-%s"
                                 (substring id 0 4)
                                 (substring id 4 6)
                                 (substring id 6 8))))
                 (keywords (denote-extract-keywords-from-path file))
                 (entry-start (point)))
            ;; Insert heading
            (insert (format "* %s" title))
            (when keywords
              (insert (format "  :%s:" (mapconcat #'identity keywords ":"))))
            (insert "\n")
            ;; Date line
            (when date
              (insert (format "  /[%s]/\n" date)))
            (insert "\n")
            ;; Content
            (condition-case nil
                (let ((content (with-temp-buffer
                                 (insert-file-contents file)
                                 (goto-char (point-min))
                                 (when (looking-at "#\\+")
                                   (while (and (not (eobp)) (looking-at "#\\+"))
                                     (forward-line 1))
                                   (forward-line 1))
                                 (buffer-substring (point) (point-max)))))
                  (insert content))
              (error nil))
            (insert "\n\n---\n\n")
            ;; Apply file property to entire entry block
            (put-text-property entry-start (point) 'denote-feed-file file)))
        (goto-char (point-min))
        (read-only-mode 1)
        ;; Keybindings for opening entries
        (use-local-map (copy-keymap org-mode-map))
        (local-set-key (kbd "RET") #'my/denote-feed-open-entry)
        (local-set-key (kbd "TAB") #'my/denote-feed-open-entry)
        (local-set-key (kbd "<tab>") #'my/denote-feed-open-entry)
        (local-set-key (kbd "e") #'my/denote-feed-open-entry)
        (local-set-key (kbd "o") #'my/denote-feed-open-entry)))
    (switch-to-buffer buf)
    (message "Journal feed: %d entries — RET/TAB to open" (length sorted))))

(provide 'init-denote)
