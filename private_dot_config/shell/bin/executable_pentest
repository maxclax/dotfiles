#!/bin/bash

# Interactive pentesting environment launcher

# Get container engine from argument or default to podman
CONTAINER_ENGINE="${1:-podman}"
SHARED_DIR="$HOME/pentest_data"

# Create shared directory if it doesn't exist
mkdir -p "$SHARED_DIR"

# Function to display menu
show_menu() {
	clear
	echo "===== PENTEST ENVIRONMENT LAUNCHER ====="
	echo "1) Parrot Security OS"
	echo "2) Kali Linux"
	echo "3) BlackArch Linux"
	echo "4) OWASP ZAP"
	echo "5) Nuclei Scanner"
	echo "6) Ronin Security Toolkit"
	echo "0) Exit"
	echo "========================================"
}

get_options() {
	OPTIONS="-it"

	echo -n "Create persistent container? (y/n): "
	read -r persistent
	if [[ "$persistent" =~ ^[Yy]$ ]]; then
		echo "Container will be persistent (not removed after exit)"
	else
		OPTIONS="$OPTIONS --rm"
		echo "Container will be removed after exit"
	fi

	echo -n "Do you want to mount a shared volume? (y/n): "
	read -r use_volume
	if [[ "$use_volume" =~ ^[Yy]$ ]]; then
		OPTIONS="$OPTIONS -v $SHARED_DIR:/data"
		echo "Shared volume will be mounted at /data inside the container"
	fi

	echo "Select network option:"
	echo "  1) Default network"
	echo "  2) Host network (direct access to host interfaces)"
	echo "  3) None (isolated)"
	echo -n "Choice [1]: "
	read -r network_choice

	case "$network_choice" in
	2)
		OPTIONS="$OPTIONS --network host"
		echo "Using host network"
		;;
	3)
		OPTIONS="$OPTIONS --network none"
		echo "Using isolated network"
		;;
	*)
		echo "Using default network"
		;;
	esac

	echo -n "Do you want to expose additional ports? (y/n): "
	read -r expose_ports
	if [[ "$expose_ports" =~ ^[Yy]$ ]]; then
		echo -n "Enter port mappings (e.g., 8080:8080 8443:8443): "
		read -r port_mappings
		for mapping in $port_mappings; do
			OPTIONS="$OPTIONS -p $mapping"
		done
	fi
}

# Main loop
while true; do
	INIT_SCRIPT=""

	show_menu
	echo -n "Select an option: "

	read -r choice

	case "$choice" in
	0)
		echo "Exiting..."
		exit 0
		;;
	1)
		IMAGE="parrotsec/security"
		NAME="parrot-security"
		;;
	2)
		IMAGE="kalilinux/kali-rolling"
		NAME="kali-linux"
		INIT_SCRIPT="apt update && apt full-upgrade -y"
		;;
	3)
		IMAGE="blackarchlinux/blackarch"
		NAME="blackarch"
		;;
	4)
		IMAGE="zaproxy/zap-stable"
		NAME="owasp-zap"
		;;
	5)
		IMAGE="projectdiscovery/nuclei"
		NAME="nuclei"
		echo -n "Enter target URL or IP address to scan (e.g., https://example.com): "
		read -r NUCLEI_TARGET
		if [[ -n "$NUCLEI_TARGET" ]]; then
			INIT_SCRIPT="nuclei -u $NUCLEI_TARGET -o /data/nuclei_results.txt"
			echo "Results will be saved to $SHARED_DIR/nuclei_results.txt"
		else
			echo "No target specified. Will launch interactive shell."
			INIT_SCRIPT="sh"
		fi
		SHELL_TYPE="sh"
		;;
	6)
		IMAGE="roninrb/ronin"
		NAME="ronin"
		;;
	*)
		echo "Invalid option selected. Press Enter to continue..."
		read -r
		continue
		;;
	esac

	echo "Configuring container options..."
	get_options
	echo "Configuration complete. Options: $OPTIONS"

	# Check if image exists locally, pull if not
	if ! $CONTAINER_ENGINE image inspect "$IMAGE" &>/dev/null; then
		echo "Image $IMAGE not found locally. Pulling..."
		$CONTAINER_ENGINE pull "$IMAGE" || {
			echo "Failed to pull image. Press Enter to continue..."
			read -r
			continue
		}
	fi

	# Check if we need to run initialization script
	CONTAINER_NAME="pentest-$NAME"

	# Default shell to use
	SHELL_TYPE="${SHELL_TYPE:-bash}"

	if [[ -n "${INIT_SCRIPT:-}" ]]; then
		# Special handling for Nuclei
		if [[ "$NAME" == "nuclei" && "$INIT_SCRIPT" != "sh" ]]; then
			echo "Nuclei will scan: $NUCLEI_TARGET"
			echo -n "Do you want to proceed with this scan? (y/n): "
			read -r run_init
			if [[ "$run_init" =~ ^[Yy]$ ]]; then
				OPTIONS="$OPTIONS --entrypoint /bin/$SHELL_TYPE"
				EXEC_CMD="-c \"$INIT_SCRIPT && $SHELL_TYPE\""
			else
				INIT_SCRIPT="$SHELL_TYPE"
				OPTIONS="$OPTIONS --entrypoint /bin/$SHELL_TYPE"
				EXEC_CMD="-c \"$SHELL_TYPE\""
			fi
		else
			echo "Initialization script for $NAME:"
			echo "$INIT_SCRIPT"
			echo -n "Do you want to run this initialization script? (y/n): "
			read -r run_init
			if [[ "$run_init" =~ ^[Yy]$ ]]; then
				OPTIONS="$OPTIONS --entrypoint /bin/$SHELL_TYPE"
				EXEC_CMD="-c \"$INIT_SCRIPT && /bin/$SHELL_TYPE\""
			else
				unset INIT_SCRIPT
			fi
		fi
	fi

	# Check if container already exists
	if $CONTAINER_ENGINE container exists "$CONTAINER_NAME" 2>/dev/null; then
		echo "Container $CONTAINER_NAME already exists."
		echo -n "Do you want to (s)tart existing container, (r)emove it and create new, or (c)ancel? [s/r/c]: "
		read -r container_action

		case "$container_action" in
		[Ss]*)
			echo "Starting existing container..."
			$CONTAINER_ENGINE start -i "$CONTAINER_NAME" || {
				echo "Failed to start container. Press Enter to continue..."
				read -r
				continue
			}
			;;
		[Rr]*)
			echo "Removing existing container..."
			$CONTAINER_ENGINE rm -f "$CONTAINER_NAME" || {
				echo "Failed to remove container. Press Enter to continue..."
				read -r
				continue
			}
			# Create new container
			echo "Creating new container..."
			if [[ -n "${INIT_SCRIPT:-}" && -n "${EXEC_CMD:-}" ]]; then
				eval "$CONTAINER_ENGINE run $OPTIONS --name \"$CONTAINER_NAME\" \"$IMAGE\" $EXEC_CMD" || {
					echo "Failed to run container. Press Enter to continue..."
					read -r
					continue
				}
			else
				$CONTAINER_ENGINE run $OPTIONS --name "$CONTAINER_NAME" "$IMAGE" || {
					echo "Failed to run container. Press Enter to continue..."
					read -r
					continue
				}
			fi
			;;
		*)
			echo "Operation cancelled."
			read -r
			continue
			;;
		esac
	else
		# Execute the container
		echo "Launching $NAME environment..."
		if [[ -n "${EXEC_CMD:-}" ]]; then
			eval "$CONTAINER_ENGINE run $OPTIONS --name \"$CONTAINER_NAME\" \"$IMAGE\" $EXEC_CMD" || {
				echo "Failed to run container. Press Enter to continue..."
				read -r
				continue
			}
		else
			$CONTAINER_ENGINE run $OPTIONS --name "$CONTAINER_NAME" "$IMAGE" || {
				echo "Failed to run container. Press Enter to continue..."
				read -r
				continue
			}
		fi
	fi

	# Reset variables for next run
	unset INIT_SCRIPT EXEC_CMD

	echo "Container session ended."
	read -r
done
