# -*- mode: makefile; -*-

# Detect the OS
UNAME_S := $(shell uname -s)
UNAME_M := $(shell uname -m)

########################################

CHEZMOI := chezmoi --source={{ .chezmoi.sourceDir }}

dotfiles_init:
	$(CHEZMOI) init
dotfiles_status:
	$(CHEZMOI) status
dotfiles_diff:
	$(CHEZMOI) diff
dotfiles_add:
	@if [ -z "$(file)" ]; then \
	  echo "Error: Please provide a FILE to add."; \
	  exit 1; \
	fi
	$(CHEZMOI) add $(file)
dotfiles_apply:
	$(CHEZMOI) apply
dotfiles_apply_extra:
	$(CHEZMOI) apply --refresh-externals
dotfiles_update:
	$(CHEZMOI) update

# Home Manager management commands

hm_diff:
	@echo "üìã Checking what will change..."
	cd ~/.config/home-manager-flake && home-manager build --flake ~/.config/home-manager-flake
	nix store diff-closures ~/.local/state/nix/profiles/home-manager ~/.config/home-manager-flake/result

hm_update:
	@echo "üîÑ Updating Home Manager flake..."
	cd ~/.config/home-manager-flake && nix flake update
	home-manager switch --flake ~/.config/home-manager-flake
	@echo "‚úÖ Update complete! Run 'make hm_commit' to commit the changes"

hm_commit:
	@echo "üìÑ Syncing flake.lock to dotfiles..."
	chezmoi add ~/.config/home-manager-flake/flake.lock
	@echo "üìù Committing updated flake.lock to dotfiles..."
	cd {{ .chezmoi.sourceDir }} && git add private_dot_config/home-manager-flake/flake.lock
	cd {{ .chezmoi.sourceDir }} && git commit -m "dev: update Home Manager flake.lock - $(shell date '+%Y-%m-%d')"
	@echo "‚úÖ flake.lock changes committed!"

hm_list:
	@echo "üì¶ Home Manager packages:"
	@home-manager packages | sort

hm_rollback:
	@echo "üîÑ Rolling back Home Manager..."
	home-manager rollback
	@echo "‚úÖ Rollback complete!"

hm_generations:
	@echo "üìã Home Manager generations:"
	home-manager generations

hm_clean:
	@echo "üßπ Cleaning up old generations..."
	home-manager expire-generations '-30 days'
	nix-collect-garbage -d
	@echo "‚úÖ Cleanup complete!"

########################################

extra_exports:
	@echo "To export API keys to your current shell, run this command:"
	@echo ""
	@echo "    source ~/extra-exports.sh"
	@echo ""
	@echo "NOTE: You must run this command directly in your terminal, not through make,"
	@echo "      because environment variables can't be exported from a Makefile to your shell."

########################################

# Determine the container engine (docker or podman)
CONTAINER_ENGINE := {{ .containerEngine }}

# Print OS-specific information
info:
ifeq ($(UNAME_S), Darwin)
	@echo "Running on macOS"
	@neofetch
else ifeq ($(UNAME_S), Linux)
	@echo "Running on Linux"
	@neofetch
endif


# Environment setup
env:
	tmuxinator main;

# Kill tmux session
tkill:
	@tmux kill-session -t main || echo "Session 'main' does not exist."

tkill_all:
	pkill -f tmux


quitapps:
ifeq ($(UNAME_S), Darwin)
	osascript -e 'tell application "System Events" to set quitapps to (name of every process whose visible is true and name is not "Finder")' \
  -e 'repeat with closeall in quitapps' \
  -e 'tell application closeall to quit' \
  -e 'end repeat'
else
	@echo "This target is for macOS only."
endif

# macOS-specific commands
get_login_items:
ifeq ($(UNAME_S), Darwin)
	@launchctl list | grep -v "apple" | awk '{print $$3}'
else
	@echo "Login items command is specific to macOS."
endif

update_os:
ifeq ($(UNAME_S), Darwin)
	@echo "Updating macOS software..."
	softwareupdate -i -a
else
	@echo "That is no Darwin."
endif

update_apps:
ifeq ($(UNAME_S), Darwin)
	@echo "Updating Home Manager..."
	$(MAKE) hm_update

	@echo "Updating Homebrew packages..."
	brew outdated ; brew update ; brew upgrade --force ; brew upgrade --cask
	brew cleanup --prune=all

	@echo "Updating App Store applications..."
	mas outdated ; mas upgrade
else
	@echo "This target is for macOS only."
endif

clear_caches:
ifeq ($(UNAME_S), Darwin)
	@echo "Clearing macOS caches..."
	rm -rf ~/Library/Caches/*
	rm -rf /Library/Caches/*
	rm -rf ~/Library/Logs/*
else
	@echo "This target is for macOS only."
endif

test_shared_volumes:
ifeq ($(UNAME_S), Darwin)
	$(CONTAINER_ENGINE) run -ti --rm \
		-v "/Volumes:/media/share/Volumes" \
		-v "/Users:/media/share/Users" \
		busybox sh -c "cd /_shared && ls && sh"
else
	@echo "This target is for macOS only."
endif

# Clean up containers
rm_a:
	@$(CONTAINER_ENGINE) ps -aq | xargs $(CONTAINER_ENGINE) stop | xargs $(CONTAINER_ENGINE) rm

# Clean up dangling (none) images
rm_none_images:
	@echo "Removing all dangling (none) images..."
	@$(CONTAINER_ENGINE) images -a | grep "<none>" | awk '{print $$3}' | xargs -r $(CONTAINER_ENGINE) rmi

# Launch k9s for Kubernetes
k9s:
	@k9s

# Tor
proxy_start:
	$(CONTAINER_ENGINE) run -d --restart=always --name torproxy -p 127.0.0.1:{{- .torproxyPortSocks5 -}}:9150/tcp -p 127.0.0.1:{{- .torproxyPortDns -}}:8853/udp peterdavehello/tor-socks-proxy:latest

torproxy_start_without_dns:
	$(CONTAINER_ENGINE) run -d --restart=always --name torproxy -p 127.0.0.1:{{- .torproxyPortSocks5 -}}:9150/tcp peterdavehello/tor-socks-proxy:latest

torproxy_stop:
	$(CONTAINER_ENGINE) stop torproxy
	$(CONTAINER_ENGINE) rm torproxy

torproxy_logs:
	$(CONTAINER_ENGINE) logs torproxy

torproxy_ip_change:
	$(CONTAINER_ENGINE) restart torproxy

torproxy_ports:
	lsof -i :{{- .torproxyPortSocks5 -}}
	lsof -i :{{- .torproxyPortDns -}}

torproxy_check:
	@echo "ALL_PROXY: ${ALL_PROXY}"
	@echo "HTTP_PROXY: ${HTTP_PROXY}"
	@echo "HTTPS_PROXY: ${HTTPS_PROXY}"
	@echo "NO_PROXY: ${NO_PROXY}"
	@echo "DNS_PROXY: ${DNS_PROXY}"

	curl https://ipinfo.tw/ip
	curl --socks5-hostname {{ .torproxyHost }}:{{- .torproxyPortSocks5 -}} https://check.torproject.org/api/ip

##############################

backup_create:
	borgmatic --verbosity 2 --progress
	borgmatic prune --verbosity 1

backup_list:
	borgmatic list --verbosity 1

backup_list_files:
    # Usage: make backup_list_files repo=/path/to/repo archive=/path/to/archive [path=optional/path/in/archive]
	@if [ -z "$(repo)" ] || [ -z "$(archive)" ]; then \
		echo "Error: Please provide repo and archive parameters."; \
		echo "Usage: make backup_list_files repo=<repository_path> archive=<archive_name> [path=<optional/path/in/archive>]"; \
		echo "Example: make backup_list_files repo=/Volumes/Backup/borg archive=daily-2023-03-12"; \
		echo "Example: make backup_list_files repo=/Volumes/Backup/borg archive=daily-2023-03-12 path=Documents"; \
		echo "Use 'make backup_list' to see available archives."; \
		exit 1; \
	fi
	@if [ -z "$(path)" ]; then \
		borg list --verbose "$(repo)::$(archive)"; \
	else \
		borg list --verbose "$(repo)::$(archive)" "$(path)"; \
	fi

backup_restore:
    # Usage: make backup_restore repo=/path/to/repo archive=/path/to/archive dest=/path/to/destination [path=optional/path/in/archive]
	@if [ -z "$(repo)" ] || [ -z "$(archive)" ] || [ -z "$(dest)" ]; then \
		echo "Error: Please provide repo, archive, and dest parameters."; \
		echo "Usage: make backup_restore repo=<repository_path> archive=<archive_name> dest=<destination_path> [path=<optional/path/in/archive>]"; \
		echo "Example: make backup_restore repo=/backups/main archive=daily-2023-01-01 dest=/recovery"; \
		echo "Example: make backup_restore repo=/backups/main archive=daily-2023-01-01 dest=/recovery path=Documents/important"; \
		echo "Use 'make backup_list' to see available archives."; \
		exit 1; \
	fi
	@if [ -z "$(path)" ]; then \
		echo "Restoring entire archive $(archive) to $(dest)..."; \
		borgmatic extract --verbosity 1 --progress --repository $(repo) --archive $(archive) --destination $(dest); \
	else \
		echo "Restoring path $(path) from archive $(archive) to $(dest)..."; \
		borgmatic extract --verbosity 1 --progress --repository $(repo) --archive $(archive) --destination $(dest) --path "$(path)"; \
	fi

##############################
